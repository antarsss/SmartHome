<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="http://172.16.199.170:3000/socket.io/socket.io.js"></script>
<div>
	<video id="live" width="320" height="240" autoplay="autoplay" style="display: inline;"></video>
	<canvas width="320" id="canvas" height="240" style="display: inline;"></canvas>
</div>

<script type="text/javascript">
	var socket = io("http://172.16.199.170:3000")
	var video = $("#live").get()[0];
	var canvas = $("#canvas");
	var ctx = canvas
		.get()[0]
		.getContext('2d');
	var options = {
		"video": true
	};

	// use the chrome specific GetUserMedia function
	navigator.getUserMedia(options, function(stream) {
		video.src = URL.createObjectURL(stream);
	}, function(err) {
		console.log("Unable to get video stream!")
	})

	timer = setInterval(function() {
		ctx.drawImage(video, 0, 0, 320, 240);
		var data = canvas
			.get()[0]
			.toDataURL('image/jpeg', 1.0);
		newblob = convertToBinary(data);
		socket.emit("stream", newblob);
	}, 125);

	function convertToBinary(dataURI) {
		// convert base64 to raw binary data held in a string doesn't handle URLEncoded DataURIs
		var byteString = atob(dataURI.split(',')[1]);

		// separate out the mime component
		var mimeString = dataURI
			.split(',')[0]
			.split(':')[1]
			.split(';')[0]

		// write the bytes of the string to an ArrayBuffer
		var ab = new ArrayBuffer(byteString.length);
		var ia = new Uint8Array(ab);
		for (var i = 0; i < byteString.length; i++) {
			ia[i] = byteString.charCodeAt(i);
		}
		// write the ArrayBuffer to a blob, and you're done
		var bb = new Blob([ab]);
		return bb;
	}
</script>